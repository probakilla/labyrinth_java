\documentclass [10pt, a4paper]{article}

\usepackage [T1]{fontenc}
\usepackage [utf8]{inputenc}
\usepackage [francais]{babel}

\title {Rapport Labyrinthe}
\author {Groupe 6}

\begin {document}

\maketitle
\newpage

\tableofcontents
\newpage

\section {Gestion des personnages}
Nous avons décidé pour la gestion des personnages, d'utiliser une classe abstraite AbstractCharacter à partir de la quelle nous avons fait hériter une classe dédiée au personnage joueur PlayableCharacter et une autre classe pour la gestion des ennemis, Enemy.

\subsection {Partie commune : AbstractCharacter}
Cette classe est la classe qui s'occupe de la gestion du personnage que l'utilisateur contrôle ainsi que les ennemis qui rôdent dans le labyrinthe. Cette classe définit et implémente les méthodes que les ennemis ainsi que le personnage utiliserons. Le type est une donnée membre qui change en fonction de la classe qui en hérite, c'est grâce à lui que l'on sait si l'on a à faire à un personnage jouable ou à un ennemi, elle nous est utile lors de la gestion des collisions. La position du joueur comme des ennemis est définie par un Vertex possédant un champ x et un champ y, qui eux représentent respectivement l'abscisse et l'ordonnée du personnage en question dans le labyrinthe. Nous pouvons gérer la position de ces derniers grâce à plusieurs méthodes :
\begin {description}
\item  [setPosition :]             Qui permet de décider où l'on souhaite placer le personnage en donnant les coordonnées auxquelles on veut le placer.
\item  [randomizePosition :]       Qui permet de placer aléatoirement un personnage dans les limites du labyrinthe.
\item  [up\/down\/left\/right\/ :] Qui permettent de déplacer le personnage dans la direction correspondante de une case.
\end   {description}
Pour la gestion des collisions, nous faisons appel à un onChangeListener, qui enverra une notification lorsque le personnage rencontre un objet dans le labyrinthe.

\subsection {Gestion du personnage jouable : PlayableCharacter}
Cette classe hérite donc de la classe AbstractCharacter détaillée au dessus. Cette classe s'occupe elle de changer son type qui est différent de celui de la classe Enemy qui partage le même héritage. Elle possède en plus d'autres données permettant la gestion du score du joueur ainsi que son nombre de vies restantes avant de perdre la partie. Pour finir avec les données membres, cette classe possède une donnée membre statique contenant le chemin vers l'image qui lui est associé pour la gestion de son affichage dans le labyrinthe. La gestion de la vie du personnage se fait grâce à un simple getter et une autre méthode qui la décrémente lors de la collision avec un ennemi. Le score lui n'est pas bien différent, elle possède un setter, un getter puis un méthode increaseScore prenant en paramètre un bonbon permettant une gestion plus facile du score lors de la collision avec ce dernier.

\subsection {Gestion des ennemis : Enemy}
Cette classe, comme la classe PlayableCharacter, hérite de AbstractCharacter. Mais celle-ci implémente l'interface Runnable qui lui permet l'utilisation de la méthode run, la faisant agir comme un thread. La classe possède tout comme PlayableCharacter un type et une chaîne de caractère correspondant au chemin de son image qui lui sont propres, mais possède en plus les coordonnées de la cible que le fantôme devra suivre, une variable indiquant si le fantôme est en déplacement, ainsi qu'un nombre entier correspondant au temps qu'il attendra en millisecondes entre chaque déplacement. L'initialisation des coordonnées de la cible à suivre se fait grâce à l'algorithme de manhattan avec le Vectrex du personnage. Contrairement au personnage, les fantômes ne sont pas contrôlés par le joueur mais doivent se déplacer tous indépendemment vers le joueur. Nous avons alors décidé d'utiliser un thread pour leur déplacement. Dans la méthode run, nous effectuons alors à chaque tour de boucle l'algorithme manhattan pour décider du prochain mouvement du fantôme en question, puis nous le faisons attendre une second (pour pas qu'il se retrouve instantanément sur le joueur).

\section {Gestion des bonbons}
Pour la gestion des bonbons dans le labyrinthe, nous avons choisir de départager ça en une interface, qui est implémentée par une classe abstraite qui est étendue par quatre classes correspondant chacune à une bonbon.
\subsection {Implémentation des bonbons}
Dans l'interface ``Candy'' des bonbons, nous ne mettons que les prototypes des méthodes permettant l'accès du type et de la positions, la majeure partie de la gestion des bonbons se fait alors dans la classe abstraite AbstractCandy. Tout comme les personnages du labyrinthe, nous avons affecté à chaque bonbon un type, présent dans la classe abstraite, ce type permettra alors de les différencier grâce à leur valeur unique à chaque classe. C'est aussi grâce à elle que nous attribuons un score lorsque le personnage en récupère un. Une fois de plus comme pour les personnages, nous avons un Vectrex responsable de la position du bonbon dans le labyrinthe ainsi que d'une chaîne de caractères pour l'affichage, elle aussi unique à chaque classe. L'unique changement entre les différentes classes de bonbons est alors le constructeur qui défini pour chaque bonbon le type correspondant ainsi que le chemin vers l'image.

\subsection {L'instanciation : design pattern factory}
Pour la gestion de l'instanciation des bonbons, nous avons choisi de suivre le design pattern factory en créant une classe CandyFactory. Cette classe n'est constituée que d'une méthode et d'aucune donnée membre. La méthode getCandy sert alors à donner à l'utilisateur un bonbon aléatoire à des coordonnées elles aussi aléatoires. La méthode vérifie tout de même si le bonbon donné n'est pas sur un emplacement qui posera problème, comme par exemple la position du joueur, d'un ennemi, de la porte de sortie du labyrinthe, d'un interrupteur, ou bien d'un autre bonbon.



\section {Gestion des déplacements}
Grâce à notre impélementation suivant le design pattern MVC, notre gestion des déplacement se fait dans la classe Controller. Dans cette classe, nous avons l'instance de PlayableCharacter (Singleton) en donnée membre, puis une tableau d'ennemis dont la taille est définie par la constante NB\_ENEMIES.

\subsection {Déplacement du personnage joueur}
Dans la méthode start du Controller, nous avons une fonction handle qui sert à capturer un évènement du clavier. Nous avons alors mit un simple switch en fonction du code retourné par l'évènement clavier, puis nous déplaçons le personnage en fonction de la direction que l'utilisateur a décidé à l'aide des flèches directionnelles.

\subsection {Déplacement des ennemis}
Contrairement au joueur, les ennemis ne sont pas des Singletons, nous avons donc dû instancier les ennemis dans le Controller pour la gestion de leur déplacements. Les ennemis sont créés lors de l'instanciation du Controller (qui est un Singleton), et leur emplacement est défini dans une boucle for du nombre d'ennemis dans la méthode init du Controller. Vu que les ennemis sont des threads, leur déplacement se fait automatiquement et de manière indépendante grâce à la méthode run implémentée dans la classe Enemy que nous avons détaillé. Il ne reste alors simplement qu'à appeler la fonction run ce qui est fait dans la méthode playGame. Cette méthode n'est utilisée que pour lancer les ennemis et est constituée d'un simple for du nombre d'ennemis qui appelle la fonction start sur chacun d'entre eux. Cette méthode playGame est alors appelée dans la méthode start du Controller qui elle est appelée dans le main, qui lance le jeu.







%%%%%A mettre dans section graph %%%%%% 
\subsection {Gestion des portes et des interrupteurs}
Nous avons une classe Door qui contient cinq données membres :
\begin {description}
\item  [switchOn :]     Un vertex correspondant au sommet contenant l'interrupteur permettant d'ouvrir la porte.
\item  [switchOff :]     Un vertex correspondant au sommet contenant l'interrupteur permettant de fermer la porte.
\item  [door :] Un edge correspondant à l'arrête contenant la porte relié aux interrupteurs.
\item  [SWITCH\_ON\_PATH :] Chaîne de caractère protégée qui contiendra le chemin vers l'image pour l'affichage de l'interrupteur d'ouverture de la porte.
\item  [SWITCH\_OFF\_PATH :] Chaîne de caractère protégée qui contiendra le chemin vers l'image pour l'affichage de l'interrupteur de fermeture de la porte.
\end   {description}
Le constructeur instancie les données switchOn, switchOff et door. On a des getters sur chacune des données membres. Et on a implémenter la méthode correctSwitchPosition qui prend en paramètre la liste des portes et celle des bonbons du graph, ainsi que la porte de sortie et l'interrupteur que l'on souhaite posé afin de vérifier que l'interrupteur ne se superposera pas avec un autre objet sur le graph.



%%%Suite de la class graph
On a implémenté la méthode doesntExist qui vérifie si le sommet, dans la direction donnée, existe. Ensuite, on a la méthode getVertex qui retourne le vertex à l'emplacement dans le tableau donnée et la méthode getVertexByDir qui retourne le vertex dans la direction donnée. On a également la méthode getEndPath qui retourne le sommet du graph le plus éloigné du premier sommet en 0.0, sachant que l'on met toujours le joueur en 0.0 cette méthode nous nous permettra de positionner la porte de sortie le plus loin possible du joueur. La méthode GraphToDot nous permet de créer un fichier graph.dot qui nous permet de visualiser le graph avec graphviz. La méthode isWall permet de savoir si, dans la direction donnée par rapport au vertex donnée, l'arrête n'existe pas, donc est un mur. La méthode getEdge nous retourne l'edge dans la direction donnée. Les méthodes isOpenedDoor et isCloseDoor permettent de savoir respectivement si l'arrête dans la direction donnée correspond à une porte ouverte ou a une porte fermée. Les méthodes setSwitchOn et setSwitchOff nous retourne le sommet pour placer correctement les interrupteurs correspondant à la porte passé en paramètre.
Les méthodes closedDoorRandom et openDoorRandom nous permettent, respectivement, de fermer et d'ouvrir une porte aléatoirement. RadomEdge retourne un edge aléatoirement utilisé pour fermé une porte aléatoirement. Random vertex retourne un sommet du graph aléatoirement, utilisé pour ouvrir une porte aléatoirement.
\end   {document}
